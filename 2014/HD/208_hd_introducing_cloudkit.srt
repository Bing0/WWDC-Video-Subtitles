

1
00:00:13.236 --> 00:00:14.526 A:middle
&gt;&gt; My name is Olivier Bonnet.

2
00:00:14.526 --> 00:00:18.266 A:middle
I'm the engineering manager for
the CloudKit on the client side.

3
00:00:20.536 --> 00:00:25.976 A:middle
So, up until today Apple
had many iCloud technologies

4
00:00:25.976 --> 00:00:28.266 A:middle
and they looked like
this to you.

5
00:00:28.426 --> 00:00:31.666 A:middle
We had iCloud Drive, iCloud
Core Data, iCloud file Library

6
00:00:31.976 --> 00:00:33.736 A:middle
and how they interacted
with the iCloud,

7
00:00:34.526 --> 00:00:36.996 A:middle
the Apple iCloud server
was kind of a mystery.

8
00:00:37.286 --> 00:00:42.276 A:middle
So today we're lifting
some of the mystery

9
00:00:42.276 --> 00:00:43.576 A:middle
in introducing CloudKit.

10
00:00:45.056 --> 00:00:47.336 A:middle
So let's look at
what we're going

11
00:00:47.336 --> 00:00:49.816 A:middle
to cover here in this session.

12
00:00:49.866 --> 00:00:53.686 A:middle
First we're going to start
with what is CloudKit.

13
00:00:55.566 --> 00:00:58.996 A:middle
We're going to walk you through
the couple of steps you need

14
00:00:58.996 --> 00:01:01.466 A:middle
to enable CloudKit in your
application and start using it.

15
00:01:02.806 --> 00:01:05.996 A:middle
We're going to do a walkthrough
of the different APIs,

16
00:01:06.676 --> 00:01:10.266 A:middle
we're going to talk about
how CloudKit interacts

17
00:01:10.266 --> 00:01:15.406 A:middle
with the Apple, the iCloud
user accounts and last

18
00:01:15.406 --> 00:01:18.786 A:middle
but not least we'll cover when
to use CloudKit as opposed

19
00:01:18.786 --> 00:01:23.426 A:middle
to other existing iCloud APIs we
already have on the platforms.

20
00:01:25.356 --> 00:01:26.416 A:middle
So let's start.

21
00:01:26.416 --> 00:01:27.286 A:middle
What is CloudKit?

22
00:01:28.576 --> 00:01:31.686 A:middle
You'll notice the new batch
but the whole session is new

23
00:01:31.786 --> 00:01:33.626 A:middle
so it's share only
on that slide.

24
00:01:35.566 --> 00:01:38.276 A:middle
[Laughter] CloudKit is
a way to give you access

25
00:01:38.276 --> 00:01:42.396 A:middle
to iCloud servers and
we really mean it.

26
00:01:42.806 --> 00:01:46.206 A:middle
CloudKit is the foundation
for both iCloud Drive

27
00:01:46.466 --> 00:01:47.736 A:middle
and iCloud file Library.

28
00:01:48.346 --> 00:01:51.586 A:middle
Those features were written
from scratch on top of CloudKit.

29
00:01:52.936 --> 00:01:55.936 A:middle
CloudKit is supported
on both OS 10 and iOS.

30
00:01:56.006 --> 00:01:58.966 A:middle
It's a new public
framework, cloudkit.framework.

31
00:01:59.436 --> 00:02:01.326 A:middle
Check it out in SDK.

32
00:02:02.596 --> 00:02:05.826 A:middle
CloudKit uses the iCloud
accounts infrastructure.

33
00:02:05.826 --> 00:02:10.376 A:middle
That means that if there's
a logged in iCloud account

34
00:02:10.376 --> 00:02:14.656 A:middle
on the device we'll use
that to identify the user.

35
00:02:15.196 --> 00:02:18.766 A:middle
If there's none, we'll provide
read only anonymous access.

36
00:02:20.006 --> 00:02:24.116 A:middle
CloudKit supports both a concept
of public and private databases.

37
00:02:24.116 --> 00:02:26.776 A:middle
You can see public
databases as a soup

38
00:02:26.776 --> 00:02:30.126 A:middle
of data that's all your
user can access to.

39
00:02:30.986 --> 00:02:36.796 A:middle
Private databases are meant
to store the actual data just

40
00:02:36.796 --> 00:02:38.296 A:middle
on behalf of a specific user.

41
00:02:41.136 --> 00:02:43.946 A:middle
CloudKit support both
structured and bulk data.

42
00:02:44.366 --> 00:02:48.646 A:middle
You can use it to store
large files on iCloud servers

43
00:02:48.646 --> 00:02:51.936 A:middle
and we'll take care of
transmitting them efficiently

44
00:02:52.286 --> 00:02:54.646 A:middle
from the iCloud servers.

45
00:02:55.926 --> 00:02:59.546 A:middle
Importantly CloudKit is
a transport technology.

46
00:02:59.776 --> 00:03:02.356 A:middle
It doesn't provide
any local persistence.

47
00:03:02.476 --> 00:03:06.946 A:middle
It enables you to send and
receive data from the servers.

48
00:03:08.766 --> 00:03:09.506 A:middle
So let's start.

49
00:03:09.696 --> 00:03:12.526 A:middle
How do you enable CloudKit
in your application?

50
00:03:12.766 --> 00:03:16.956 A:middle
So first you'll want to navigate
your application's capabilities,

51
00:03:16.956 --> 00:03:18.006 A:middle
pane and X code.

52
00:03:18.236 --> 00:03:21.056 A:middle
See that big iCloud off switch?

53
00:03:21.056 --> 00:03:24.266 A:middle
You want to turn
it on and you want

54
00:03:24.266 --> 00:03:28.056 A:middle
to check the CloudKit
checkbox here.

55
00:03:28.746 --> 00:03:29.806 A:middle
At that point you're ready.

56
00:03:30.026 --> 00:03:30.986 A:middle
There's no fourth step.

57
00:03:32.646 --> 00:03:35.166 A:middle
Your app is ready to
read and write data

58
00:03:35.206 --> 00:03:39.776 A:middle
to Apple's iCloud server and to
walk you through the API on how

59
00:03:39.776 --> 00:03:43.656 A:middle
to do this I'm going to hand
over to Paul to chat about it.

60
00:03:43.656 --> 00:03:43.723 A:middle
[Applause]

61
00:03:43.723 --> 00:03:44.476 A:middle
&gt;&gt; All right.

62
00:03:45.156 --> 00:03:45.866 A:middle
Thank you, Olivier.

63
00:03:46.516 --> 00:03:49.996 A:middle
[ Applause ]

64
00:03:50.496 --> 00:03:52.156 A:middle
So, as Olivier said,
my name is Paul.

65
00:03:52.156 --> 00:03:54.966 A:middle
I work on the CloudKit client
framework, and I'm very excited

66
00:03:54.966 --> 00:03:57.276 A:middle
to talk to you guys
today about CloudKit.

67
00:03:57.356 --> 00:03:59.446 A:middle
We're going to start off
we're going to start talking

68
00:03:59.446 --> 00:04:01.746 A:middle
about the fundamental
CloudKit objects.

69
00:04:01.796 --> 00:04:03.206 A:middle
These are going to
be the set of objects

70
00:04:03.206 --> 00:04:05.336 A:middle
that you're initially
exposed to when you open up

71
00:04:05.336 --> 00:04:06.986 A:middle
and start playing with
the CloudKit framework.

72
00:04:07.976 --> 00:04:10.016 A:middle
Just running through a quick
list of them we're going to talk

73
00:04:10.016 --> 00:04:12.616 A:middle
about containers and we're
going to talk about databases,

74
00:04:12.976 --> 00:04:15.396 A:middle
we're going to talk about
records, we're going to talk

75
00:04:15.396 --> 00:04:19.706 A:middle
about record zones
and RecordIDentifiers,

76
00:04:20.196 --> 00:04:21.555 A:middle
we're going to talk
about references

77
00:04:21.555 --> 00:04:23.126 A:middle
and we're going to
talk about assets.

78
00:04:23.126 --> 00:04:23.766 A:middle
It's quite a list.

79
00:04:23.766 --> 00:04:26.886 A:middle
This is going to be a really fun
and really jam-packed session.

80
00:04:27.226 --> 00:04:31.046 A:middle
So let's get started and we're
going to talk about containers.

81
00:04:31.786 --> 00:04:33.876 A:middle
This is sort of the
idealized model

82
00:04:34.106 --> 00:04:36.656 A:middle
of your application
talking about iCloud.

83
00:04:36.656 --> 00:04:39.706 A:middle
Now you guys are
application developers,

84
00:04:39.706 --> 00:04:42.046 A:middle
you guys are client
developers, and you know

85
00:04:42.046 --> 00:04:44.856 A:middle
that your application
running on a client whether

86
00:04:44.856 --> 00:04:46.216 A:middle
that client is a iPhone

87
00:04:46.276 --> 00:04:49.556 A:middle
or whether it be a Mac Book
yours is not the only process

88
00:04:49.556 --> 00:04:50.446 A:middle
running on that client.

89
00:04:50.876 --> 00:04:52.106 A:middle
Rather yours is one of many.

90
00:04:52.906 --> 00:04:56.486 A:middle
Now on your client your
process is going to be siloed,

91
00:04:56.486 --> 00:04:57.926 A:middle
sandboxed in some ways.

92
00:04:58.616 --> 00:05:02.206 A:middle
In some cases, it's
a literal sandbox.

93
00:05:02.236 --> 00:05:03.166 A:middle
Certainly in others
you're running

94
00:05:03.166 --> 00:05:04.326 A:middle
in your own memory space.

95
00:05:05.006 --> 00:05:06.926 A:middle
This concept of taking
your client

96
00:05:06.926 --> 00:05:08.666 A:middle
and actually running
it separated

97
00:05:08.666 --> 00:05:10.656 A:middle
from other clients
is pretty powerful.

98
00:05:10.656 --> 00:05:12.176 A:middle
It has got a couple
of advantages.

99
00:05:12.326 --> 00:05:15.256 A:middle
It helps with security,
it helps with stability

100
00:05:15.256 --> 00:05:16.646 A:middle
and it helps with privacy.

101
00:05:17.506 --> 00:05:20.536 A:middle
So as we are figuring out how
we wanted to build CloudKit,

102
00:05:20.586 --> 00:05:23.456 A:middle
we thought to ourselves how can
we take these three advantages

103
00:05:23.846 --> 00:05:25.336 A:middle
and replicate them
up in the server?

104
00:05:25.336 --> 00:05:28.026 A:middle
So here's what we did.

105
00:05:28.026 --> 00:05:30.836 A:middle
Just as your client is
one of many, I'm sorry,

106
00:05:30.936 --> 00:05:33.076 A:middle
your application is one of
many running on the client,

107
00:05:33.516 --> 00:05:35.806 A:middle
so too the part of
iCloud that you're talking

108
00:05:35.806 --> 00:05:39.056 A:middle
to is one of many up on iCloud.

109
00:05:39.096 --> 00:05:41.016 A:middle
We call these different
silos containers.

110
00:05:41.646 --> 00:05:43.966 A:middle
So containers.

111
00:05:44.456 --> 00:05:46.566 A:middle
Containers are exposed
in the CloudKit framework

112
00:05:46.566 --> 00:05:48.556 A:middle
as the CKContainer class.

113
00:05:48.556 --> 00:05:49.626 A:middle
CK is our prefix
and you're going

114
00:05:49.626 --> 00:05:51.326 A:middle
to see this all over the place.

115
00:05:51.466 --> 00:05:54.146 A:middle
By default one application
talks to one container.

116
00:05:55.546 --> 00:05:58.336 A:middle
Containers afford us the
ability to segregate data.

117
00:05:58.866 --> 00:06:01.306 A:middle
That means that your application
can read and write data

118
00:06:01.306 --> 00:06:03.856 A:middle
to iCloud, another application
can read and write data

119
00:06:03.856 --> 00:06:05.586 A:middle
to iCloud and the two datasets

120
00:06:05.586 --> 00:06:07.326 A:middle
up on the server will
not be intermingled.

121
00:06:08.256 --> 00:06:11.986 A:middle
In addition to data segregation,
this containerization

122
00:06:11.986 --> 00:06:15.876 A:middle
of iCloud storage allows us to
encapsulate user information.

123
00:06:16.626 --> 00:06:17.876 A:middle
Now as Olivier mentioned,

124
00:06:18.226 --> 00:06:21.776 A:middle
CloudKit involves using the
iCloud account infrastructure

125
00:06:22.266 --> 00:06:24.496 A:middle
and we want to give
you some limited access

126
00:06:24.556 --> 00:06:26.896 A:middle
to that iCloud account
and we want to make sure

127
00:06:26.896 --> 00:06:29.816 A:middle
that we're doing so in a
privacy conscientious manner.

128
00:06:30.436 --> 00:06:33.486 A:middle
So in order to do that, we
encapsulate user information.

129
00:06:33.946 --> 00:06:36.406 A:middle
User information available
to your application is going

130
00:06:36.406 --> 00:06:38.116 A:middle
to be container scoped
and, therefore,

131
00:06:38.116 --> 00:06:41.416 A:middle
different than the view
of user information seen

132
00:06:41.416 --> 00:06:42.456 A:middle
by another application.

133
00:06:43.896 --> 00:06:46.076 A:middle
Containers are managed
by you the developer.

134
00:06:46.076 --> 00:06:49.256 A:middle
You're going to be managing
them via the WWDR portal.

135
00:06:50.186 --> 00:06:52.796 A:middle
It's important to note
that the name space

136
00:06:52.796 --> 00:06:55.616 A:middle
of containers is
global to all developers

137
00:06:55.966 --> 00:06:58.046 A:middle
so when you're choosing a name
for your container make sure

138
00:06:58.046 --> 00:06:59.366 A:middle
that you're using
it in a reverse,

139
00:06:59.406 --> 00:07:01.706 A:middle
you're using a reverse DNS name.

140
00:07:02.986 --> 00:07:06.606 A:middle
Now, right up there just like
a little while ago I said

141
00:07:06.606 --> 00:07:08.876 A:middle
that by default there
is one container

142
00:07:08.876 --> 00:07:10.736 A:middle
to one application,
a one to one mapping.

143
00:07:11.406 --> 00:07:14.486 A:middle
We think this is going to be
successful for 99% of use cases

144
00:07:14.756 --> 00:07:17.126 A:middle
and certainly as you go and
start using CloudKit it's going

145
00:07:17.126 --> 00:07:18.896 A:middle
to be great as you start
exploring the framework.

146
00:07:19.316 --> 00:07:21.566 A:middle
We recognize that there
are some scenarios

147
00:07:21.566 --> 00:07:23.386 A:middle
where you need a
more complex mapping

148
00:07:23.716 --> 00:07:25.426 A:middle
so we support a many
to many model.

149
00:07:25.526 --> 00:07:29.166 A:middle
What we mean is that multiple
applications can coordinate

150
00:07:29.166 --> 00:07:31.026 A:middle
on the same iCloud container.

151
00:07:32.046 --> 00:07:34.006 A:middle
Also a single application
can talk

152
00:07:34.006 --> 00:07:35.496 A:middle
to multiple iCloud containers.

153
00:07:38.306 --> 00:07:39.266 A:middle
On to databases.

154
00:07:40.226 --> 00:07:42.686 A:middle
One of the chief purposes
of CloudKit is the ability

155
00:07:42.686 --> 00:07:45.516 A:middle
to take your object model in
your application and replicate

156
00:07:45.516 --> 00:07:46.356 A:middle
that up to the server.

157
00:07:46.786 --> 00:07:49.206 A:middle
So when we start
thinking about how we want

158
00:07:49.206 --> 00:07:51.436 A:middle
to present this modeling
to you we thought

159
00:07:51.436 --> 00:07:54.486 A:middle
to ourselves how can we
divide up application objects?

160
00:07:54.486 --> 00:07:55.706 A:middle
Obviously all objects

161
00:07:55.706 --> 00:07:57.776 A:middle
in my application are
not treated equally.

162
00:07:58.536 --> 00:08:01.116 A:middle
One of the first things that we
notice was there's a fundamental

163
00:08:01.116 --> 00:08:03.796 A:middle
difference in the
audience of data.

164
00:08:04.576 --> 00:08:08.246 A:middle
Some data is intended to be used
by the user that created it.

165
00:08:08.736 --> 00:08:11.136 A:middle
If you imagine an application
where I'm writing up notes

166
00:08:11.136 --> 00:08:13.236 A:middle
and I want to see my notes
everywhere else, that's my data.

167
00:08:13.276 --> 00:08:15.576 A:middle
I create it, I consume it.

168
00:08:15.956 --> 00:08:19.386 A:middle
On the other hand, there's use
for what we call public data.

169
00:08:19.816 --> 00:08:23.026 A:middle
This is data that can be,
a, created by the user

170
00:08:23.026 --> 00:08:24.316 A:middle
for the benefit of a community;

171
00:08:24.686 --> 00:08:26.856 A:middle
think perhaps a review
on a restaurant.

172
00:08:27.676 --> 00:08:29.916 A:middle
Or it could be information that
you the developer has uploaded

173
00:08:29.916 --> 00:08:32.265 A:middle
to iCloud because it's
useful to your application.

174
00:08:33.025 --> 00:08:35.736 A:middle
In either case, the audience
is not just a single user

175
00:08:35.736 --> 00:08:36.686 A:middle
but a community of people.

176
00:08:37.395 --> 00:08:38.895 A:middle
So how did we solve the fact

177
00:08:38.895 --> 00:08:40.756 A:middle
that we've got these
different types of data.

178
00:08:41.346 --> 00:08:43.306 A:middle
Let's break open a container
and have a look inside.

179
00:08:44.186 --> 00:08:46.596 A:middle
Inside of a container
you're going to notice first

180
00:08:46.596 --> 00:08:48.026 A:middle
and foremost the
public database.

181
00:08:48.026 --> 00:08:50.236 A:middle
This is the soup, this is
where all of the public

182
00:08:50.236 --> 00:08:52.886 A:middle
and communal data
co-lives, co-mingles.

183
00:08:53.946 --> 00:08:55.036 A:middle
Additionally, you're
going to notice

184
00:08:55.036 --> 00:08:57.366 A:middle
that there's private databases
and you're going to find

185
00:08:57.366 --> 00:08:59.076 A:middle
that there's an individual
private database

186
00:08:59.076 --> 00:09:00.716 A:middle
for each user of
your application.

187
00:09:01.436 --> 00:09:03.836 A:middle
Now this is sort of the
50,000 foot overview

188
00:09:03.836 --> 00:09:05.466 A:middle
of what the iCloud
infrastructure looks like,

189
00:09:05.606 --> 00:09:07.866 A:middle
but you know, how much do
you guys care about that?

190
00:09:08.186 --> 00:09:09.186 A:middle
What you guys are interested

191
00:09:09.186 --> 00:09:11.156 A:middle
in is what does this
infrastructure look

192
00:09:11.156 --> 00:09:13.726 A:middle
like to me the client running
on a phone or running on a Mac.

193
00:09:14.736 --> 00:09:16.196 A:middle
Obviously you're only
going to have access

194
00:09:16.196 --> 00:09:18.026 A:middle
to the currently
logged in iCloud user.

195
00:09:18.216 --> 00:09:20.246 A:middle
So rather than seeing
a public database

196
00:09:20.246 --> 00:09:22.926 A:middle
and a gajillion private
databases, your view is going

197
00:09:22.926 --> 00:09:24.116 A:middle
to look a little
bit more like this.

198
00:09:24.256 --> 00:09:26.196 A:middle
You're going to have a choice
between a public database

199
00:09:26.656 --> 00:09:28.486 A:middle
or the private database
that is correlated

200
00:09:28.486 --> 00:09:30.006 A:middle
to the currently
logged in iCloud user.

201
00:09:31.096 --> 00:09:32.556 A:middle
So databases.

202
00:09:33.096 --> 00:09:36.606 A:middle
Databases are exposed in our
API as a CK database class.

203
00:09:37.176 --> 00:09:38.866 A:middle
Every application has
access to two of them,

204
00:09:39.266 --> 00:09:40.516 A:middle
the public and the private.

205
00:09:41.376 --> 00:09:44.266 A:middle
Let's have a look at
a little bit of code.

206
00:09:44.556 --> 00:09:47.206 A:middle
The container is the initial
entry point into CloudKit.

207
00:09:47.726 --> 00:09:49.726 A:middle
Here we see that I am talking
to my default container

208
00:09:50.066 --> 00:09:51.496 A:middle
and getting its public database.

209
00:09:51.876 --> 00:09:53.276 A:middle
I can also talk to
the default container

210
00:09:53.276 --> 00:09:54.476 A:middle
and get it to private database.

211
00:09:55.186 --> 00:09:56.296 A:middle
Let's have a look
at the differences

212
00:09:56.296 --> 00:09:57.646 A:middle
between these 2 databases.

213
00:09:58.396 --> 00:10:01.166 A:middle
As we mentioned, the
desired audience is going

214
00:10:01.166 --> 00:10:02.906 A:middle
to be different between
the public database

215
00:10:02.906 --> 00:10:03.796 A:middle
and the private database.

216
00:10:03.836 --> 00:10:06.476 A:middle
The public db is for shared
data, the private db is

217
00:10:06.476 --> 00:10:07.386 A:middle
for the user's own data.

218
00:10:08.586 --> 00:10:11.116 A:middle
As such, we have different
requirements for whether

219
00:10:11.116 --> 00:10:13.756 A:middle
or not an iCloud account
needs to exist on the client.

220
00:10:14.566 --> 00:10:16.766 A:middle
In the private database,
since I am reading

221
00:10:16.766 --> 00:10:19.566 A:middle
and writing a user's data if
we have no notion of the user,

222
00:10:19.696 --> 00:10:23.206 A:middle
that is if we don't have a login
iCloud account there's really no

223
00:10:23.206 --> 00:10:24.806 A:middle
utility in moving
this information

224
00:10:24.806 --> 00:10:26.336 A:middle
to and from the server.

225
00:10:26.656 --> 00:10:29.336 A:middle
So we require an iCloud account
to be logged in if you want

226
00:10:29.336 --> 00:10:30.446 A:middle
to use the private database.

227
00:10:30.996 --> 00:10:33.446 A:middle
In the public database since
the audience is more communal,

228
00:10:33.686 --> 00:10:37.086 A:middle
we allow you read only anonymous
access to the public database.

229
00:10:40.466 --> 00:10:42.796 A:middle
You'll recall from
yesterday's talk

230
00:10:42.876 --> 00:10:45.476 A:middle
that CloudKit is
free with Linux.

231
00:10:45.846 --> 00:10:48.816 A:middle
So we've got some
pretty aggressive quotas.

232
00:10:49.266 --> 00:10:50.826 A:middle
That being said we
still need to account

233
00:10:50.886 --> 00:10:53.846 A:middle
for where data is being used
so that we can talk to you

234
00:10:53.846 --> 00:10:55.516 A:middle
when we start approaching
those limits.

235
00:10:56.086 --> 00:10:59.086 A:middle
Data stored in the public
database is accounted

236
00:10:59.086 --> 00:11:00.196 A:middle
for on the developer's quota.

237
00:11:00.416 --> 00:11:02.226 A:middle
Date stored in the private
database is accounted

238
00:11:02.226 --> 00:11:03.126 A:middle
for on the user's quota.

239
00:11:04.256 --> 00:11:07.066 A:middle
By default data written
into the public database is

240
00:11:07.066 --> 00:11:07.776 A:middle
world readable.

241
00:11:08.466 --> 00:11:10.796 A:middle
Data written to the private
database is user readable.

242
00:11:10.986 --> 00:11:13.636 A:middle
Again it's the user's own data
so they're really the only ones

243
00:11:13.636 --> 00:11:15.586 A:middle
to have access to it in
the private database.

244
00:11:16.756 --> 00:11:20.816 A:middle
We recognize that world readable
is not an appropriate permission

245
00:11:20.816 --> 00:11:22.606 A:middle
for a lot of data in
the public database

246
00:11:22.926 --> 00:11:25.416 A:middle
so we give you the ability
to edit these permissions

247
00:11:25.416 --> 00:11:27.456 A:middle
on a record class level.

248
00:11:28.306 --> 00:11:31.126 A:middle
The mechanism by which you edit
these permissions is something

249
00:11:31.126 --> 00:11:33.376 A:middle
that we call the
iCloud Dashboard roles.

250
00:11:33.946 --> 00:11:36.286 A:middle
iCloud Dashboard is the
administrative interface

251
00:11:36.346 --> 00:11:37.306 A:middle
into CloudKit.

252
00:11:37.926 --> 00:11:39.696 A:middle
I invite you guys to
come back on Thursday

253
00:11:39.746 --> 00:11:40.536 A:middle
for the advanced talk.

254
00:11:40.536 --> 00:11:43.246 A:middle
We're going to go into a lot
of detail about the dashboard.

255
00:11:43.926 --> 00:11:46.446 A:middle
Suffice it to say there's
an ability to set ACLs

256
00:11:46.726 --> 00:11:48.926 A:middle
so that a user is
a member of a role

257
00:11:49.376 --> 00:11:52.356 A:middle
and a role can have
certain enlarged access

258
00:11:52.356 --> 00:11:53.436 A:middle
to a class of records.

259
00:11:54.246 --> 00:11:56.396 A:middle
In the private database,
things start

260
00:11:56.396 --> 00:11:58.136 A:middle
out in lockdown there's
no need to edit them.

261
00:11:58.236 --> 00:12:00.036 A:middle
The user is the only
one to create data

262
00:12:00.036 --> 00:12:01.966 A:middle
and the user is the only one
to be able to read that data.

263
00:12:02.506 --> 00:12:04.856 A:middle
When I say that the user is
the only one to be able to read

264
00:12:04.856 --> 00:12:06.136 A:middle
that data, I really mean it.

265
00:12:06.226 --> 00:12:08.836 A:middle
You as the developer
do not have access

266
00:12:08.836 --> 00:12:10.456 A:middle
into somebody else's
private database.

267
00:12:10.606 --> 00:12:11.536 A:middle
Their data is their own.

268
00:12:11.536 --> 00:12:14.546 A:middle
All right so those
are databases.

269
00:12:14.906 --> 00:12:15.896 A:middle
Let's talk about records.

270
00:12:17.376 --> 00:12:19.946 A:middle
So, here's our model
that we have so far.

271
00:12:19.946 --> 00:12:22.246 A:middle
We've got a container, within
containers are databases.

272
00:12:22.246 --> 00:12:24.696 A:middle
Let's keep going down the rabbit
hole and crack open a database.

273
00:12:25.096 --> 00:12:27.326 A:middle
Inside the database we see
that it's full of records.

274
00:12:29.086 --> 00:12:32.056 A:middle
Records are exposed in our
framework as the CKRecord class.

275
00:12:32.196 --> 00:12:35.156 A:middle
They are the mechanism by which
you've moved structured data

276
00:12:35.226 --> 00:12:36.406 A:middle
to and from CloudKit.

277
00:12:37.816 --> 00:12:41.536 A:middle
CKRecords wrap key value pairs.

278
00:12:41.626 --> 00:12:44.316 A:middle
Lest you think that a CKRecord
is just a glorified dictionary,

279
00:12:44.316 --> 00:12:45.486 A:middle
there are some additional
attributes

280
00:12:45.486 --> 00:12:47.816 A:middle
that make it worthwhile
of being in its own class.

281
00:12:47.866 --> 00:12:49.916 A:middle
To start off with records
have a record type.

282
00:12:50.726 --> 00:12:53.326 A:middle
If CloudKit is a mechanism by
which you take your object graph

283
00:12:53.326 --> 00:12:55.406 A:middle
from your application and
move it into CloudKit,

284
00:12:55.816 --> 00:12:57.126 A:middle
then let's continue
with that analogy.

285
00:12:57.586 --> 00:13:00.416 A:middle
An instance of an object in
your application is equivalent

286
00:13:00.466 --> 00:13:02.386 A:middle
to an instance of a CKRecord.

287
00:13:02.936 --> 00:13:05.006 A:middle
Similarly the class
of the object

288
00:13:05.006 --> 00:13:07.076 A:middle
in your application
is equivalent

289
00:13:07.076 --> 00:13:08.886 A:middle
to the record type
of the CKRecord.

290
00:13:11.286 --> 00:13:12.976 A:middle
Records have a just
in time schema.

291
00:13:13.196 --> 00:13:16.726 A:middle
You do not need to tell CloudKit
about what your data looks

292
00:13:16.826 --> 00:13:18.866 A:middle
like before you hand
CloudKit your data.

293
00:13:19.686 --> 00:13:23.076 A:middle
Hand us your data and
we'll figure it out.

294
00:13:23.966 --> 00:13:27.046 A:middle
CloudKit, excuse me,
CKRecord also supports a raft

295
00:13:27.046 --> 00:13:28.156 A:middle
of metadata.

296
00:13:28.466 --> 00:13:30.636 A:middle
For example, a record
understands

297
00:13:30.636 --> 00:13:32.296 A:middle
when it was created
and who created it.

298
00:13:32.896 --> 00:13:35.246 A:middle
It understands when a
record was last modified

299
00:13:35.246 --> 00:13:36.976 A:middle
and who last modified it.

300
00:13:36.976 --> 00:13:40.016 A:middle
Lastly a record contains
a notion of a change tag.

301
00:13:40.016 --> 00:13:42.596 A:middle
A change tag is a
version of a record.

302
00:13:42.596 --> 00:13:45.246 A:middle
It represents a specific
revision of this record.

303
00:13:45.686 --> 00:13:47.836 A:middle
It's use so that we can
have a lightweight way

304
00:13:47.836 --> 00:13:50.286 A:middle
of determining whether or not
a client server had the same

305
00:13:50.286 --> 00:13:51.106 A:middle
version of a record.

306
00:13:51.746 --> 00:13:55.756 A:middle
Let's talk a little bit
about record values,

307
00:13:55.756 --> 00:13:57.406 A:middle
CKRecords wrap key value pairs.

308
00:13:57.806 --> 00:13:59.596 A:middle
What are the acceptable
value types

309
00:13:59.596 --> 00:14:01.046 A:middle
that you can put
into a CKRecord?

310
00:14:01.736 --> 00:14:04.646 A:middle
Well, we've got your usual
suspects, your P list types,

311
00:14:04.646 --> 00:14:07.646 A:middle
your strings, your numbers,
your datas and your dates.

312
00:14:07.716 --> 00:14:09.476 A:middle
We think that especially

313
00:14:09.476 --> 00:14:11.636 A:middle
in the public database
domain location is an

314
00:14:11.636 --> 00:14:12.466 A:middle
interesting scenario.

315
00:14:12.736 --> 00:14:16.246 A:middle
So, CLLocation is a native type
that you can set on a CKRecord.

316
00:14:17.686 --> 00:14:20.336 A:middle
You can set CKReferences and
CKAssets and we're going to go

317
00:14:20.336 --> 00:14:21.596 A:middle
over what those are
in just a moment.

318
00:14:22.846 --> 00:14:25.206 A:middle
Lastly any value can
be a single instance.

319
00:14:25.206 --> 00:14:29.006 A:middle
I can have a string or a date
or it can be a homogenous array.

320
00:14:29.256 --> 00:14:32.536 A:middle
I can have an array of numbers
or an array of CKAssets.

321
00:14:32.536 --> 00:14:37.686 A:middle
Let's have a look at
a little bit of code.

322
00:14:38.206 --> 00:14:39.746 A:middle
Here we see a CKRecord.

323
00:14:39.826 --> 00:14:41.676 A:middle
The CKRecord Initializer
takes a record type

324
00:14:41.676 --> 00:14:44.256 A:middle
because that's an invaluable
and necessary piece of a record.

325
00:14:44.976 --> 00:14:47.806 A:middle
You can set objects
and get objects

326
00:14:47.806 --> 00:14:49.506 A:middle
from a record using
a dictionary syntax

327
00:14:49.696 --> 00:14:51.836 A:middle
or a keyed subscripting syntax.

328
00:14:52.486 --> 00:14:55.026 A:middle
We also give you the ability to
enumerate all keys on a record

329
00:14:55.336 --> 00:14:57.926 A:middle
so that you can dump the
entire key value pair.

330
00:14:57.926 --> 00:15:00.886 A:middle
Let's have a look at
a specific example.

331
00:15:01.596 --> 00:15:03.326 A:middle
Now, throughout this
talk my example is going

332
00:15:03.326 --> 00:15:05.806 A:middle
to be an application that I've
created for me and my friends.

333
00:15:05.996 --> 00:15:09.016 A:middle
This application allows us to
create parties and we're going

334
00:15:09.016 --> 00:15:11.546 A:middle
to stick party records
in the public database.

335
00:15:11.546 --> 00:15:13.776 A:middle
A party might be a
structured data it's going

336
00:15:13.776 --> 00:15:15.536 A:middle
to have a summary, a
start date and end date

337
00:15:15.536 --> 00:15:17.846 A:middle
and it might also have
additional metadata

338
00:15:17.846 --> 00:15:19.016 A:middle
that we associate with it,

339
00:15:19.256 --> 00:15:20.576 A:middle
pictures of the party,
et cetera.

340
00:15:21.746 --> 00:15:23.716 A:middle
So, how do I create
a party record?

341
00:15:24.246 --> 00:15:26.016 A:middle
Well I create one just
as you might imagine

342
00:15:26.016 --> 00:15:28.176 A:middle
with a party record type.

343
00:15:28.896 --> 00:15:31.276 A:middle
I can now set values on
it and I can read values

344
00:15:31.276 --> 00:15:34.536 A:middle
from it using the dictionary
or key subscripting syntax.

345
00:15:35.226 --> 00:15:35.986 A:middle
Those are records.

346
00:15:36.756 --> 00:15:38.156 A:middle
Let's talk about record zones.

347
00:15:38.596 --> 00:15:41.386 A:middle
This is the model that we've
just presented and it was kind

348
00:15:41.386 --> 00:15:44.466 A:middle
of a lie but it was a
useful lie at the time.

349
00:15:45.276 --> 00:15:51.236 A:middle
So, records don't exist by
themselves just as objects

350
00:15:51.236 --> 00:15:52.946 A:middle
in your application don't
exist by themselves.

351
00:15:52.946 --> 00:15:54.756 A:middle
There's going to be a
natural grouping of objects

352
00:15:54.756 --> 00:15:55.656 A:middle
within your application.

353
00:15:56.046 --> 00:15:58.516 A:middle
Similarly we want a way

354
00:15:58.516 --> 00:16:00.576 A:middle
to express this grouping
in CloudKit.

355
00:16:00.756 --> 00:16:03.926 A:middle
Fundamentally we're trying
via CloudKit to take as much

356
00:16:03.926 --> 00:16:06.336 A:middle
of your knowledge about your
object graph and reflect

357
00:16:06.336 --> 00:16:07.096 A:middle
that up to the server.

358
00:16:08.066 --> 00:16:10.466 A:middle
So the way that we group
records is via something

359
00:16:10.466 --> 00:16:11.646 A:middle
that we call a record zone.

360
00:16:12.566 --> 00:16:14.606 A:middle
There can be multiple
records within a record zone

361
00:16:15.246 --> 00:16:17.916 A:middle
and there can be multiple
record zones within a database.

362
00:16:18.666 --> 00:16:21.046 A:middle
Every database has a
default record zone.

363
00:16:21.366 --> 00:16:24.486 A:middle
Some databases support
additional custom record zones.

364
00:16:25.386 --> 00:16:27.686 A:middle
Record zones are the
default granularity

365
00:16:27.686 --> 00:16:28.296 A:middle
at which you're going

366
00:16:28.296 --> 00:16:30.426 A:middle
to do atomic commits
and change tracking.

367
00:16:31.016 --> 00:16:32.716 A:middle
If either of those sound
interesting to you,

368
00:16:32.716 --> 00:16:34.596 A:middle
I invite you back on Thursday
for the advanced talk.

369
00:16:34.596 --> 00:16:37.406 A:middle
We're going to go over
a whole bunch of that.

370
00:16:37.616 --> 00:16:38.996 A:middle
So, those were record zones.

371
00:16:38.996 --> 00:16:40.496 A:middle
Let's talk about
RecordIDentifiers.

372
00:16:41.366 --> 00:16:45.846 A:middle
RecordIDentifiers, let's get
the code up there, are a tuple.

373
00:16:45.846 --> 00:16:48.306 A:middle
They represent both a
client provided record name

374
00:16:48.876 --> 00:16:51.696 A:middle
and also the zone in which
that record name exists.

375
00:16:52.676 --> 00:16:54.046 A:middle
So what are their
characteristics?

376
00:16:54.556 --> 00:16:56.946 A:middle
Number one they are
created by the client.

377
00:16:57.306 --> 00:17:01.246 A:middle
You get to specify the ID,
the record name of the record,

378
00:17:02.456 --> 00:17:04.695 A:middle
but because we are
coupling this record name,

379
00:17:04.826 --> 00:17:08.596 A:middle
which is scoped per record
zone, along with a reference

380
00:17:08.656 --> 00:17:09.996 A:middle
to the owning record zone,

381
00:17:10.455 --> 00:17:13.236 A:middle
they become a fully normalized
representation of the record.

382
00:17:13.326 --> 00:17:15.256 A:middle
It's the full path to it.

383
00:17:15.256 --> 00:17:19.695 A:middle
We think that it's going to be
fairly common for you to try

384
00:17:19.695 --> 00:17:22.246 A:middle
and bridge an external
dataset into CloudKit.

385
00:17:22.596 --> 00:17:25.746 A:middle
If you're doing so and if your
external dataset has a unique

386
00:17:25.746 --> 00:17:30.716 A:middle
key, using that unique key
as the CKRecordID allows you

387
00:17:30.716 --> 00:17:32.956 A:middle
to have a foreign key back
into your external dataset.

388
00:17:33.236 --> 00:17:34.436 A:middle
Totally an approved usage.

389
00:17:35.646 --> 00:17:37.186 A:middle
Let's have a look at some code.

390
00:17:37.616 --> 00:17:39.626 A:middle
Here we are, you know,
creating a record,

391
00:17:39.626 --> 00:17:40.446 A:middle
you've seen that already,

392
00:17:41.076 --> 00:17:43.236 A:middle
and we've got multiple
initializers for CKRecord.

393
00:17:43.366 --> 00:17:45.126 A:middle
You can either choose
to provide us a RecordID

394
00:17:45.126 --> 00:17:46.106 A:middle
or you can choose not to.

395
00:17:46.236 --> 00:17:48.216 A:middle
If you choose not to
provide a RecordID,

396
00:17:48.466 --> 00:17:51.206 A:middle
we're going to assign a random
view UUID to the record.

397
00:17:52.206 --> 00:17:55.556 A:middle
Also note here that when I
created my RecordID I chose not

398
00:17:55.556 --> 00:17:56.726 A:middle
to give it a zone.

399
00:17:57.186 --> 00:17:59.946 A:middle
Throughout CloudKit's
API if you choose not

400
00:17:59.946 --> 00:18:01.556 A:middle
to give us a record zone,
we're going to assume

401
00:18:01.556 --> 00:18:02.856 A:middle
that you meant the default zone.

402
00:18:03.156 --> 00:18:06.346 A:middle
So here, I am creating
a RecordID

403
00:18:06.346 --> 00:18:08.306 A:middle
with the name well-known
party that exists

404
00:18:08.306 --> 00:18:09.216 A:middle
within the default zone.

405
00:18:10.316 --> 00:18:11.526 A:middle
So those are RecordIDs.

406
00:18:12.066 --> 00:18:13.406 A:middle
Now let's talk about references.

407
00:18:14.126 --> 00:18:16.386 A:middle
Just as there's a natural
grouping of records that we want

408
00:18:16.386 --> 00:18:18.976 A:middle
to expose via a record
zone, there's also going

409
00:18:18.976 --> 00:18:20.996 A:middle
to be a natural relationship
between objects.

410
00:18:21.746 --> 00:18:24.776 A:middle
For example, let's say that in
addition to being able to write

411
00:18:24.776 --> 00:18:27.156 A:middle
up parties I can assign
different clowns to parties

412
00:18:27.186 --> 00:18:28.466 A:middle
because what is the
point of a party

413
00:18:28.466 --> 00:18:29.806 A:middle
if you don't have a few clowns?

414
00:18:30.206 --> 00:18:31.916 A:middle
So, I want some way

415
00:18:32.276 --> 00:18:36.146 A:middle
of representing the object
relationship that I have

416
00:18:36.146 --> 00:18:39.056 A:middle
between parties and clowns up
to the server and the way we do

417
00:18:39.056 --> 00:18:40.946 A:middle
that is via something
that we call references.

418
00:18:41.756 --> 00:18:45.726 A:middle
Now you'll note here that in
this contrived example parties

419
00:18:45.776 --> 00:18:46.636 A:middle
own clowns.

420
00:18:46.636 --> 00:18:49.336 A:middle
That is we've got a parent/child
relationship with the party

421
00:18:49.336 --> 00:18:50.896 A:middle
as a parent and the
clown as a child

422
00:18:50.896 --> 00:18:54.276 A:middle
and that the reference
goes from the child object,

423
00:18:54.276 --> 00:18:56.446 A:middle
from the clown, up
to its parent object.

424
00:18:56.816 --> 00:18:58.846 A:middle
We call that a back reference.

425
00:19:00.316 --> 00:19:03.816 A:middle
References are exposing API
as the CKReference class.

426
00:19:03.816 --> 00:19:05.516 A:middle
They are a way of letting
the server understand the

427
00:19:05.516 --> 00:19:06.916 A:middle
relationship between records.

428
00:19:07.516 --> 00:19:09.086 A:middle
When the server understands
the relationship

429
00:19:09.086 --> 00:19:11.166 A:middle
between records it can do
very interesting things

430
00:19:11.236 --> 00:19:12.576 A:middle
such as cascade delete.

431
00:19:13.216 --> 00:19:16.266 A:middle
If the server notices that
you've deleted a record

432
00:19:16.266 --> 00:19:19.676 A:middle
and that record is the parent in
a parent and child relationship,

433
00:19:20.196 --> 00:19:21.896 A:middle
the server will automatically
go ahead

434
00:19:21.896 --> 00:19:24.556 A:middle
and cascade delete all
the children of that item.

435
00:19:25.116 --> 00:19:28.086 A:middle
With any database
the scope and scale

436
00:19:28.146 --> 00:19:31.396 A:middle
of CloudKit dangling pointers
are going to become a necessary

437
00:19:31.396 --> 00:19:35.326 A:middle
and inconvenient truth
of your use of CloudKit.

438
00:19:35.916 --> 00:19:38.256 A:middle
By the time you fetch a record
and you read a reference,

439
00:19:38.386 --> 00:19:40.246 A:middle
then you go and fetch the
target of that reference,

440
00:19:40.246 --> 00:19:41.536 A:middle
the target may not exist.

441
00:19:41.976 --> 00:19:44.746 A:middle
So it's important that you're
code is resilient to this.

442
00:19:46.156 --> 00:19:49.076 A:middle
Again, as I mentioned, we
prefer back references.

443
00:19:49.076 --> 00:19:52.046 A:middle
It's not a requirement, but it's
more efficient if references go

444
00:19:52.046 --> 00:19:54.126 A:middle
from child objects
to parent objects.

445
00:19:54.256 --> 00:19:55.836 A:middle
This is the tip of the iceberg

446
00:19:55.836 --> 00:19:58.766 A:middle
in a very large topic
called data modeling

447
00:19:59.066 --> 00:20:00.606 A:middle
and if you come back
on Thursday we're going

448
00:20:00.606 --> 00:20:02.526 A:middle
to tell you a whole bunch about
data modeling in CloudKit.

449
00:20:03.296 --> 00:20:05.746 A:middle
Let's have a look at some code.

450
00:20:06.766 --> 00:20:11.006 A:middle
Here we see creating a reference
between two CKRecord instances

451
00:20:11.006 --> 00:20:14.316 A:middle
that I have in memory,
but it's not necessary

452
00:20:14.316 --> 00:20:16.516 A:middle
that I have the target
of a reference in memory.

453
00:20:17.146 --> 00:20:19.986 A:middle
I can make a reference
that points at a RecordID.

454
00:20:20.656 --> 00:20:23.096 A:middle
This allows me to refer to a
record that I've got, you know,

455
00:20:23.236 --> 00:20:25.326 A:middle
reason to believe
exists up on the server.

456
00:20:26.116 --> 00:20:28.636 A:middle
If I were to save this record
and the target didn't exist,

457
00:20:28.636 --> 00:20:31.706 A:middle
I'd actually be creating a
dangling pointer and that's okay

458
00:20:31.706 --> 00:20:33.926 A:middle
because the code you're going
to write is going to support

459
00:20:34.076 --> 00:20:36.106 A:middle
and be resilient in the
face of dangling pointers.

460
00:20:37.466 --> 00:20:39.976 A:middle
So those are references now
let's talk about assets.

461
00:20:40.236 --> 00:20:43.716 A:middle
Here we have our
model again just

462
00:20:43.716 --> 00:20:45.466 A:middle
to refresh our container
database record

463
00:20:46.366 --> 00:20:50.146 A:middle
and now let's take the idea
that I want to write a record,

464
00:20:50.146 --> 00:20:53.056 A:middle
I want to write a party record
up to the server, but let's say

465
00:20:53.056 --> 00:20:55.626 A:middle
that I want to associate a
large file with that record.

466
00:20:55.746 --> 00:20:57.036 A:middle
Let's say, for example,
that we're going

467
00:20:57.036 --> 00:20:59.496 A:middle
to have a get together after
the presentation and I'm going

468
00:20:59.496 --> 00:21:01.316 A:middle
to read you a screen play
that I've been working on.

469
00:21:02.266 --> 00:21:03.666 A:middle
Now I know, I understand

470
00:21:03.666 --> 00:21:04.906 A:middle
that there's different
characteristics

471
00:21:04.906 --> 00:21:06.186 A:middle
between these different datas.

472
00:21:06.246 --> 00:21:09.156 A:middle
I understand that the record
about the party is structured,

473
00:21:09.306 --> 00:21:11.136 A:middle
you know, it's got a summary,
it's got a start date,

474
00:21:11.136 --> 00:21:14.636 A:middle
it's got an end date and, you
know, just innately I believe

475
00:21:14.636 --> 00:21:15.376 A:middle
that I want the server

476
00:21:15.376 --> 00:21:17.776 A:middle
to understand those
bits about the record.

477
00:21:18.126 --> 00:21:20.826 A:middle
If you contrast that to
the screen play, well,

478
00:21:20.826 --> 00:21:23.016 A:middle
the screen play is just
essentially a bag of bits.

479
00:21:23.266 --> 00:21:24.826 A:middle
I don't feel any real need

480
00:21:24.826 --> 00:21:26.556 A:middle
to tell the server how
my screen play breaks

481
00:21:26.556 --> 00:21:29.266 A:middle
down into amazing acts and,
you know, dashing scenes,

482
00:21:29.916 --> 00:21:32.876 A:middle
but I do know that
I want to treat them

483
00:21:32.876 --> 00:21:33.836 A:middle
as just an opaque bag.

484
00:21:34.296 --> 00:21:35.646 A:middle
So how do we solve this?

485
00:21:35.646 --> 00:21:38.256 A:middle
Well, we're going to
solve this and we're going

486
00:21:38.256 --> 00:21:40.396 A:middle
to solve the fact that data
has different characteristics

487
00:21:40.396 --> 00:21:42.086 A:middle
like this in two different ways.

488
00:21:42.836 --> 00:21:44.716 A:middle
Up on the server we're
going to introduce a notion

489
00:21:44.716 --> 00:21:46.186 A:middle
that we call bulk storage.

490
00:21:46.836 --> 00:21:48.716 A:middle
As you might expect,
bulk storage is great

491
00:21:48.716 --> 00:21:49.926 A:middle
for storing bulk data.

492
00:21:51.176 --> 00:21:54.966 A:middle
Similarly on the client
you're going to tell CloudKit

493
00:21:54.966 --> 00:21:56.746 A:middle
about the different
characteristics of your data

494
00:21:57.036 --> 00:21:58.946 A:middle
by treating some
of it as a CKRecord

495
00:21:59.296 --> 00:22:01.146 A:middle
and other bits of
it as a CKAsset.

496
00:22:01.436 --> 00:22:04.296 A:middle
A CKAsset is the representation
of this bag of bits.

497
00:22:04.656 --> 00:22:06.766 A:middle
Now when you ask CloudKit
to save this record,

498
00:22:07.246 --> 00:22:08.326 A:middle
the appropriate bits
are going to go

499
00:22:08.326 --> 00:22:09.386 A:middle
in the appropriate database.

500
00:22:09.476 --> 00:22:11.186 A:middle
Structured data in
public database,

501
00:22:11.246 --> 00:22:12.846 A:middle
bulk data in bulk storage.

502
00:22:13.646 --> 00:22:15.136 A:middle
So assets.

503
00:22:15.396 --> 00:22:19.466 A:middle
Assets are exposed in our
framework as the CKAsset class.

504
00:22:19.526 --> 00:22:21.226 A:middle
They represent large,
unstructured data.

505
00:22:22.196 --> 00:22:24.396 A:middle
Because you don't necessarily
want large unstructured data

506
00:22:24.396 --> 00:22:26.826 A:middle
in memory, the way you
communicate assets to

507
00:22:26.826 --> 00:22:29.156 A:middle
and from CloudKit is
via files on disks.

508
00:22:30.506 --> 00:22:32.266 A:middle
Assets are owned by records.

509
00:22:32.376 --> 00:22:33.746 A:middle
This gives us a nice
tight coupling

510
00:22:33.746 --> 00:22:34.896 A:middle
between a record and an asset.

511
00:22:36.186 --> 00:22:39.596 A:middle
What this allows the server to
do is garbage collect assets.

512
00:22:40.006 --> 00:22:42.826 A:middle
Even though that we're storing
this data in two separate areas

513
00:22:43.216 --> 00:22:45.866 A:middle
when the server detects a delete
for a record it can go ahead

514
00:22:45.866 --> 00:22:48.676 A:middle
and clean up any assets that
were owned by that record.

515
00:22:49.936 --> 00:22:53.336 A:middle
Lastly because we expect CKAsset
to be large, opaque data,

516
00:22:53.636 --> 00:22:56.756 A:middle
we go through some great pains
to try and move that data to

517
00:22:56.756 --> 00:22:58.516 A:middle
and from the server as
efficiently as possible.

518
00:22:58.676 --> 00:23:01.316 A:middle
This is all sort of inside
of CloudKit but we're going

519
00:23:01.316 --> 00:23:03.926 A:middle
to send only the bits
that the minimal amount

520
00:23:03.926 --> 00:23:04.676 A:middle
of bits that we can.

521
00:23:05.386 --> 00:23:07.496 A:middle
Let's have a look at some code.

522
00:23:08.566 --> 00:23:11.876 A:middle
Here I'm creating a
CKAsset based on a file URL

523
00:23:11.876 --> 00:23:14.296 A:middle
to my screen play
on disk and just

524
00:23:14.296 --> 00:23:18.076 A:middle
like any other CKRecord value
supporting class I'm setting it

525
00:23:18.076 --> 00:23:19.296 A:middle
on CKRecord.

526
00:23:19.986 --> 00:23:22.856 A:middle
So these are the fundamental
objects in CloudKit.

527
00:23:23.266 --> 00:23:24.806 A:middle
The first thing you
talk to is a container.

528
00:23:25.176 --> 00:23:27.056 A:middle
Within a container are
two different databases.

529
00:23:27.516 --> 00:23:30.196 A:middle
Databases contains
records, records are wrapped

530
00:23:30.196 --> 00:23:31.746 A:middle
and grouped within record zones.

531
00:23:32.136 --> 00:23:34.666 A:middle
You identify a record
via a RecordIDentifier

532
00:23:35.286 --> 00:23:39.086 A:middle
and records are related to
one another via references

533
00:23:39.086 --> 00:23:41.016 A:middle
and large bulk data
is transmitted to

534
00:23:41.016 --> 00:23:43.356 A:middle
and from CloudKit via CKAssets.

535
00:23:45.286 --> 00:23:46.216 A:middle
All right you guys made it

536
00:23:46.216 --> 00:23:48.086 A:middle
through the nouns now
let's get into the verbs.

537
00:23:50.486 --> 00:23:53.206 A:middle
[Laughter] CloudKit we
offer two different APIs

538
00:23:53.206 --> 00:23:54.176 A:middle
for using CloudKit.

539
00:23:54.416 --> 00:23:56.986 A:middle
We call them the operational
API and the convenience API.

540
00:23:57.786 --> 00:24:00.086 A:middle
The operational API
has every single bell

541
00:24:00.086 --> 00:24:01.536 A:middle
and whistle you might
care about.

542
00:24:01.536 --> 00:24:07.806 A:middle
In some cases, you're going to
want to tweak every single bell

543
00:24:07.806 --> 00:24:09.896 A:middle
and whistle to fit your
application's model,

544
00:24:10.926 --> 00:24:14.246 A:middle
but not every application really
wants to do all of this tweaking

545
00:24:14.406 --> 00:24:16.406 A:middle
and not every application
has enough knowledge

546
00:24:16.406 --> 00:24:17.786 A:middle
to set these bits correctly.

547
00:24:18.186 --> 00:24:20.206 A:middle
Sometimes you want to let
the framework make some

548
00:24:20.206 --> 00:24:22.596 A:middle
of these decisions
on your behalf.

549
00:24:22.596 --> 00:24:25.536 A:middle
So, we offer the
convenience API.

550
00:24:25.876 --> 00:24:27.946 A:middle
It's convenient, it's
going to be what you want

551
00:24:27.946 --> 00:24:30.206 A:middle
to start off playing with when
you start looking at CloudKit.

552
00:24:30.316 --> 00:24:32.766 A:middle
For many uses of
CloudKit it's all

553
00:24:32.766 --> 00:24:35.396 A:middle
that you're going
to need to touch.

554
00:24:35.576 --> 00:24:37.696 A:middle
So quickly we're going to go
over how you save a record

555
00:24:37.696 --> 00:24:40.036 A:middle
in the convenience of API,
how you fetch a record

556
00:24:40.036 --> 00:24:42.726 A:middle
from the server via
the convenience of API

557
00:24:42.726 --> 00:24:45.966 A:middle
and how you can take a
fetched record, modify it

558
00:24:45.966 --> 00:24:47.386 A:middle
and save it back
up to the server.

559
00:24:48.526 --> 00:24:49.986 A:middle
Let's start off with
saving a record.

560
00:24:52.876 --> 00:24:53.996 A:middle
Here I am creating a record.

561
00:24:53.996 --> 00:24:55.926 A:middle
You guys are now very
well familiar with this.

562
00:24:57.566 --> 00:24:59.196 A:middle
When I want to save the
record, I have to choose

563
00:24:59.196 --> 00:25:02.176 A:middle
which database I
want to save it into.

564
00:25:02.176 --> 00:25:03.206 A:middle
Here I'm going to save the data

565
00:25:03.206 --> 00:25:05.536 A:middle
into the public database
and how do I do that?

566
00:25:06.096 --> 00:25:08.896 A:middle
Well, I call the save record
with completion handler method.

567
00:25:08.896 --> 00:25:12.136 A:middle
Now I want you guys to
note three separate things

568
00:25:12.136 --> 00:25:13.686 A:middle
about this code right here.

569
00:25:14.306 --> 00:25:15.856 A:middle
First of all it's very simple.

570
00:25:16.266 --> 00:25:17.946 A:middle
You guys aren't providing
a lot of options,

571
00:25:17.946 --> 00:25:19.936 A:middle
you're delegating a lot
of the bells and whistles

572
00:25:19.936 --> 00:25:21.536 A:middle
like how important is this,

573
00:25:21.596 --> 00:25:23.326 A:middle
what interface should
I send this data over,

574
00:25:23.736 --> 00:25:25.536 A:middle
you're delegating those
choices off to CloudKit.

575
00:25:26.576 --> 00:25:28.616 A:middle
Second, it's asynchronous.

576
00:25:28.946 --> 00:25:30.056 A:middle
As Olivier mentioned,

577
00:25:30.056 --> 00:25:32.536 A:middle
the CloudKit does not
have local persistence.

578
00:25:32.616 --> 00:25:33.996 A:middle
We are a transport technology.

579
00:25:34.466 --> 00:25:36.136 A:middle
We're going to transport
your data up to the server

580
00:25:36.136 --> 00:25:38.196 A:middle
and we'll store it on the server
and we'll transport it back

581
00:25:38.196 --> 00:25:39.556 A:middle
down to other clients.

582
00:25:40.316 --> 00:25:43.626 A:middle
So when you save a record
via CloudKit, we are going

583
00:25:43.626 --> 00:25:45.716 A:middle
to attempt to save that
record directly to the server.

584
00:25:46.186 --> 00:25:48.916 A:middle
If it fails, we're going to tell
you about that immediately or,

585
00:25:49.016 --> 00:25:50.086 A:middle
you know, as quickly as we can.

586
00:25:51.396 --> 00:25:53.526 A:middle
Now we don't want
to block threads

587
00:25:53.616 --> 00:25:55.006 A:middle
and we don't want you
to block the user.

588
00:25:55.226 --> 00:25:56.816 A:middle
So we don't want to make
this a synchronous call.

589
00:25:57.256 --> 00:25:59.006 A:middle
So here we've got an
asynchronous call.

590
00:26:00.366 --> 00:26:02.206 A:middle
Now the third thing
I want you to note is

591
00:26:02.206 --> 00:26:05.236 A:middle
that even though is a very
simple method we do provide an

592
00:26:05.236 --> 00:26:06.696 A:middle
error as part of the call back.

593
00:26:07.136 --> 00:26:09.516 A:middle
Now if you've been
to WWC in the past

594
00:26:09.516 --> 00:26:11.036 A:middle
or if you've watched
any presentations,

595
00:26:11.036 --> 00:26:12.516 A:middle
you've seen something
that looks like this.

596
00:26:12.516 --> 00:26:14.096 A:middle
We've got an Apple
developer up here

597
00:26:14.096 --> 00:26:16.976 A:middle
and the Apple developer says
you need to handle errors

598
00:26:16.976 --> 00:26:18.096 A:middle
that return from our framework.

599
00:26:18.096 --> 00:26:21.496 A:middle
Now, I'm not calling them
liars it's true you do need

600
00:26:21.496 --> 00:26:23.216 A:middle
to handle errors
returned from frameworks.

601
00:26:23.216 --> 00:26:26.386 A:middle
In many applications, it's
the difference between a good

602
00:26:26.386 --> 00:26:28.506 A:middle
and functioning application
and a great application.

603
00:26:29.616 --> 00:26:30.846 A:middle
CloudKit is a little
bit different.

604
00:26:31.366 --> 00:26:33.276 A:middle
CloudKit by its very
nature is going

605
00:26:33.276 --> 00:26:34.506 A:middle
to be talking over the network.

606
00:26:34.756 --> 00:26:36.196 A:middle
Networks are inherently
lossy [phonetic].

607
00:26:36.516 --> 00:26:38.926 A:middle
Phones like to fall off
the network all the time.

608
00:26:38.926 --> 00:26:42.046 A:middle
So, in CloudKit, the difference
between handling an error

609
00:26:42.046 --> 00:26:44.376 A:middle
versus not handling an error
is really the difference

610
00:26:44.376 --> 00:26:46.606 A:middle
between a functional and
a non-functional app.

611
00:26:47.106 --> 00:26:49.026 A:middle
Error handling has got to
be one of the first things

612
00:26:49.026 --> 00:26:50.936 A:middle
that you look at when
you start using CloudKit.

613
00:26:50.936 --> 00:26:53.416 A:middle
I'm going to be a little bit
glib throughout the slides here

614
00:26:53.416 --> 00:26:54.976 A:middle
but every time you
see a comment imagine

615
00:26:54.976 --> 00:26:57.146 A:middle
that you're seeing just some
really nice error handling.

616
00:26:57.876 --> 00:27:02.486 A:middle
[Laughter] So let's talk about
now that we've saved a record

617
00:27:02.486 --> 00:27:04.146 A:middle
up to the server, how do
we fetch a record back

618
00:27:04.146 --> 00:27:04.986 A:middle
down from the server?

619
00:27:05.756 --> 00:27:09.646 A:middle
I'm going to start by
deciding which database I want

620
00:27:09.646 --> 00:27:10.486 A:middle
to fetch a record from.

621
00:27:10.556 --> 00:27:13.666 A:middle
I'm then going to construct
a RecordID, the identifier

622
00:27:13.666 --> 00:27:16.526 A:middle
of the record I care
to fetch down.

623
00:27:16.526 --> 00:27:19.456 A:middle
Here I've gotten this name
either via some side channel

624
00:27:19.456 --> 00:27:21.136 A:middle
or something that's built
into my application.

625
00:27:22.586 --> 00:27:25.396 A:middle
I then can ask the database
to fetch a record with ID

626
00:27:25.396 --> 00:27:26.226 A:middle
with completion handler.

627
00:27:26.826 --> 00:27:30.296 A:middle
Again, asynchronous, simple,
amazing error handling.

628
00:27:32.276 --> 00:27:35.026 A:middle
Once I fetched a record let's
get that code back up here,

629
00:27:35.546 --> 00:27:38.886 A:middle
I want you to note that the
successful return value is an

630
00:27:38.886 --> 00:27:40.646 A:middle
actual CKRecord instance

631
00:27:40.646 --> 00:27:43.016 A:middle
and this is a live
honest to God CKRecord.

632
00:27:43.536 --> 00:27:45.726 A:middle
Let's say I'm having so much
fun at this party I pulled

633
00:27:46.126 --> 00:27:47.586 A:middle
that I want it to last
a little bit longer.

634
00:27:47.776 --> 00:27:50.346 A:middle
I can take a record off of it
and I can bump out the end date

635
00:27:50.346 --> 00:27:52.486 A:middle
by half an hour and I
can set that record,

636
00:27:52.486 --> 00:27:53.816 A:middle
that value back on the record.

637
00:27:54.656 --> 00:27:57.476 A:middle
Once I've done that I can take
my CKRecord instance and just

638
00:27:57.476 --> 00:27:59.776 A:middle
like one that I've created
locally I can turn around

639
00:27:59.776 --> 00:28:02.506 A:middle
and save it back up
to the database again

640
00:28:02.506 --> 00:28:03.456 A:middle
with amazing error handling.

641
00:28:04.496 --> 00:28:07.586 A:middle
All right so that's
the convenience API,

642
00:28:07.586 --> 00:28:09.396 A:middle
the initial typical flow
that you're going to go

643
00:28:09.446 --> 00:28:10.446 A:middle
through when talking
with CloudKit.

644
00:28:10.446 --> 00:28:12.586 A:middle
You're going to be saving
records, fetching records

645
00:28:12.996 --> 00:28:16.086 A:middle
and taking those records that
you fetched modifying them

646
00:28:16.236 --> 00:28:18.096 A:middle
and putting them back
up to the server.

647
00:28:19.096 --> 00:28:21.926 A:middle
So now let's say my party
application starts becoming

648
00:28:21.926 --> 00:28:24.056 A:middle
really popular and it's grown.

649
00:28:24.056 --> 00:28:27.476 A:middle
My user base is no longer me and
my friends but it's all of you.

650
00:28:27.476 --> 00:28:29.906 A:middle
Everyone is really excited
about joining into the parties.

651
00:28:30.586 --> 00:28:32.216 A:middle
What are some of the problems
I'm going to run into?

652
00:28:32.986 --> 00:28:35.506 A:middle
Well, let's assume
that when I started

653
00:28:35.506 --> 00:28:37.306 A:middle
out I was a relatively
naive developer

654
00:28:37.566 --> 00:28:40.276 A:middle
and because the developer on
stage said CloudKit is all

655
00:28:40.276 --> 00:28:41.856 A:middle
about taking your object
graph and moving it to

656
00:28:41.856 --> 00:28:43.956 A:middle
and from the cloud,
that's exactly what I did.

657
00:28:43.956 --> 00:28:45.586 A:middle
I had the one to one mapping.

658
00:28:45.806 --> 00:28:47.766 A:middle
My objects went up to the Cloud

659
00:28:48.016 --> 00:28:50.546 A:middle
and on every client I would
fetch the entire cloud state

660
00:28:50.546 --> 00:28:52.056 A:middle
and that would become
my object graph.

661
00:28:52.486 --> 00:28:53.996 A:middle
What are some problems
we're going to run into?

662
00:28:54.876 --> 00:28:57.776 A:middle
Well, at that point we've got
big data and a very tiny phone.

663
00:28:58.626 --> 00:29:00.776 A:middle
The more popular my app
becomes the more data

664
00:29:00.776 --> 00:29:03.876 A:middle
on the database the less
reasonable it is to have a cache

665
00:29:03.876 --> 00:29:06.406 A:middle
of that entire data
locally on my device.

666
00:29:06.816 --> 00:29:08.016 A:middle
So how are we going
to solve this.

667
00:29:08.016 --> 00:29:10.186 A:middle
Let's think about
what we want to do.

668
00:29:10.776 --> 00:29:13.456 A:middle
We want to keep the large
data up in the Cloud.

669
00:29:13.606 --> 00:29:15.726 A:middle
The Cloud is very good at
storing large datasets.

670
00:29:16.366 --> 00:29:18.676 A:middle
My client wants to view
a slice of that data.

671
00:29:19.276 --> 00:29:21.556 A:middle
Because I'm writing an
application for my users

672
00:29:21.556 --> 00:29:24.666 A:middle
and my users have their own
preferences, I want each client

673
00:29:24.666 --> 00:29:26.716 A:middle
to be able to view a
different slice of that data

674
00:29:26.916 --> 00:29:28.406 A:middle
and each individual
client might want

675
00:29:28.406 --> 00:29:29.926 A:middle
to change its view of that data.

676
00:29:30.776 --> 00:29:34.246 A:middle
The way we saw this is via
something that we call queries.

677
00:29:35.176 --> 00:29:37.616 A:middle
Clients use queries to
focus their viewpoint

678
00:29:38.076 --> 00:29:40.986 A:middle
so that they can see a small
section of a large dataset

679
00:29:41.076 --> 00:29:42.586 A:middle
that exists up on the cloud.

680
00:29:43.556 --> 00:29:45.506 A:middle
So what is a query?

681
00:29:45.506 --> 00:29:47.606 A:middle
As you might imagine,
it's exposed in our API

682
00:29:47.606 --> 00:29:49.536 A:middle
as the CK query class.

683
00:29:50.666 --> 00:29:52.866 A:middle
A query combines three
different things.

684
00:29:52.866 --> 00:29:54.706 A:middle
It combines a record
type, a predicate

685
00:29:55.096 --> 00:29:56.796 A:middle
and optionally a
sort descriptor.

686
00:29:57.986 --> 00:30:00.126 A:middle
If you've used NS
predicate in the past,

687
00:30:00.126 --> 00:30:02.046 A:middle
you know that NS predicate
is very expressive.

688
00:30:03.036 --> 00:30:04.986 A:middle
CloudKit supports
most of NS predicate.

689
00:30:05.226 --> 00:30:08.746 A:middle
We document the parts that we do
and if you hand us a predicate

690
00:30:08.746 --> 00:30:10.576 A:middle
that we don't understand, we're
going to throw an exception.

691
00:30:10.716 --> 00:30:12.406 A:middle
So you're going to learn
pretty quickly which ones are

692
00:30:12.406 --> 00:30:13.046 A:middle
and are not supported.

693
00:30:13.046 --> 00:30:13.976 A:middle
Let's have a look at
some that are supported.

694
00:30:14.126 --> 00:30:19.476 A:middle
Here we see a predicate
that would match records

695
00:30:19.706 --> 00:30:21.936 A:middle
where name is equal to
a value I had in memory.

696
00:30:23.376 --> 00:30:25.636 A:middle
Predicates allow you
to use dynamic keys

697
00:30:25.636 --> 00:30:28.126 A:middle
so that I don't have to know
the key name at compile time.

698
00:30:29.166 --> 00:30:31.386 A:middle
We can do relative
ordering comparisons

699
00:30:31.386 --> 00:30:32.856 A:middle
as opposed to strict equalities.

700
00:30:33.436 --> 00:30:36.846 A:middle
We mentioned that location
is an interesting aspect

701
00:30:36.846 --> 00:30:37.836 A:middle
in the public database.

702
00:30:37.906 --> 00:30:40.656 A:middle
So you can query with
location as a filter.

703
00:30:41.136 --> 00:30:43.306 A:middle
This is every location
within a 100 meters

704
00:30:43.306 --> 00:30:44.726 A:middle
of where we're standing
here in Moscone.

705
00:30:46.716 --> 00:30:48.736 A:middle
CloudKit supports a
tokenization search.

706
00:30:49.096 --> 00:30:52.616 A:middle
So, what this predicate is going
to do is it's going to tokenize

707
00:30:52.706 --> 00:30:55.376 A:middle
that string after session
and it's going to come

708
00:30:55.376 --> 00:30:57.906 A:middle
up with two different
tokens, after and session.

709
00:30:58.726 --> 00:31:00.466 A:middle
This predicate will
match any record

710
00:31:00.466 --> 00:31:03.106 A:middle
that has those two
tokens as values.

711
00:31:03.806 --> 00:31:05.996 A:middle
These two tokens don't
need to exist side by side,

712
00:31:06.076 --> 00:31:08.176 A:middle
they don't even need to exist
in the same key value pair,

713
00:31:08.736 --> 00:31:10.846 A:middle
but so long as the
record has the token after

714
00:31:11.096 --> 00:31:13.726 A:middle
and the record has the token
session the record will be

715
00:31:13.726 --> 00:31:14.226 A:middle
a match.

716
00:31:15.826 --> 00:31:19.656 A:middle
Lastly, CloudKit supports
compound predicates joined using

717
00:31:19.656 --> 00:31:20.676 A:middle
the and operator.

718
00:31:21.216 --> 00:31:23.086 A:middle
Here we see a predicate
that does that.

719
00:31:25.406 --> 00:31:26.826 A:middle
Here we see the creation
of a query

720
00:31:27.086 --> 00:31:30.846 A:middle
and as we mentioned it's
combining both a record type

721
00:31:30.846 --> 00:31:31.426 A:middle
and a predicate.

722
00:31:32.956 --> 00:31:35.076 A:middle
How do I perform queries
after I've created them?

723
00:31:36.186 --> 00:31:39.176 A:middle
Well, just like saving records
performing a query is going

724
00:31:39.176 --> 00:31:41.186 A:middle
to be a database
specific operation.

725
00:31:41.396 --> 00:31:42.866 A:middle
So I'm going to choose
the database

726
00:31:42.866 --> 00:31:45.646 A:middle
on which I want to
perform a query.

727
00:31:45.756 --> 00:31:48.966 A:middle
Even in the simple API and the
convenience API we give you the

728
00:31:48.966 --> 00:31:52.096 A:middle
ability to restrict these
queries by record zones.

729
00:31:52.176 --> 00:31:54.166 A:middle
You see here that we're
not choosing to pass

730
00:31:54.166 --> 00:31:55.056 A:middle
in a record zone filter.

731
00:31:55.506 --> 00:31:56.886 A:middle
So this query is going to search

732
00:31:56.886 --> 00:31:58.436 A:middle
across the entire
public database.

733
00:31:58.946 --> 00:32:01.156 A:middle
Let's have a look
at what happens

734
00:32:01.226 --> 00:32:02.796 A:middle
in the completion handler.

735
00:32:03.026 --> 00:32:05.306 A:middle
First, of course,
amazing error handling.

736
00:32:05.736 --> 00:32:08.146 A:middle
Second, if we don't have errors,

737
00:32:08.146 --> 00:32:09.456 A:middle
let's have a look
at the results.

738
00:32:09.456 --> 00:32:12.736 A:middle
You'll see here that the results
are actually CKRecord instances.

739
00:32:12.736 --> 00:32:13.936 A:middle
These are live objects.

740
00:32:14.426 --> 00:32:16.506 A:middle
If I wanted to, I could
pull data off of them,

741
00:32:16.506 --> 00:32:18.886 A:middle
I could set data on them
and I could even choose

742
00:32:18.886 --> 00:32:20.226 A:middle
to save them back to the server.

743
00:32:20.226 --> 00:32:26.446 A:middle
So a way to think about queries
is that queries are polls

744
00:32:26.446 --> 00:32:28.446 A:middle
and polls are great
in some scenarios.

745
00:32:28.826 --> 00:32:31.036 A:middle
They're great for slicing
through large datasets.

746
00:32:31.286 --> 00:32:33.666 A:middle
If your application wants to
start up and, for example,

747
00:32:33.666 --> 00:32:36.566 A:middle
show all the parties, the top
10 parties that are near me,

748
00:32:36.986 --> 00:32:40.516 A:middle
a query is absolutely the way
to go, but there's other things

749
00:32:40.516 --> 00:32:41.726 A:middle
that you might be
tempted to use a query

750
00:32:41.726 --> 00:32:43.116 A:middle
for that are not perfect.

751
00:32:43.116 --> 00:32:46.806 A:middle
If you find yourself issuing
the same query over and over

752
00:32:46.806 --> 00:32:49.516 A:middle
and over again and you're
getting back a static,

753
00:32:49.516 --> 00:32:53.116 A:middle
a mostly same data
result set, well,

754
00:32:53.116 --> 00:32:55.866 A:middle
then you've got a large
mostly static dataset

755
00:32:55.866 --> 00:32:58.606 A:middle
and queries are bad for that
use case for a few reasons.

756
00:32:59.336 --> 00:33:00.506 A:middle
They're bad for battery life.

757
00:33:00.636 --> 00:33:03.106 A:middle
You have to constantly
wake the device up, poll,

758
00:33:03.106 --> 00:33:05.986 A:middle
run the same query and get back
more or less the same results.

759
00:33:06.886 --> 00:33:08.026 A:middle
They're bad for network traffic.

760
00:33:08.236 --> 00:33:09.956 A:middle
All those questions
go to the server

761
00:33:09.956 --> 00:33:11.436 A:middle
and if they're not
pulling down new

762
00:33:11.436 --> 00:33:13.706 A:middle
and interesting data,
why do we bother?

763
00:33:14.486 --> 00:33:17.036 A:middle
They are also bad for
the user experience.

764
00:33:17.286 --> 00:33:20.506 A:middle
By definition, you're only
going to learn about new results

765
00:33:20.506 --> 00:33:24.056 A:middle
on the period of how
often you're polling.

766
00:33:24.726 --> 00:33:26.796 A:middle
Users nowadays have
come to expect push.

767
00:33:27.816 --> 00:33:30.386 A:middle
So as opposed to using
a client-generated query

768
00:33:30.386 --> 00:33:33.146 A:middle
in the scenario, what you really
want is you want the server

769
00:33:33.146 --> 00:33:34.616 A:middle
to be running the
query on your behalf.

770
00:33:35.466 --> 00:33:37.276 A:middle
You want the server to be
running the query on your behalf

771
00:33:37.366 --> 00:33:39.306 A:middle
in the background and
you want that to happen

772
00:33:39.306 --> 00:33:41.756 A:middle
after every single record
save whether it was you

773
00:33:41.756 --> 00:33:43.336 A:middle
or somebody else that
saved the record.

774
00:33:44.146 --> 00:33:46.136 A:middle
Lastly, of course,
you want pushes

775
00:33:46.136 --> 00:33:47.976 A:middle
when the results have changes.

776
00:33:48.816 --> 00:33:51.086 A:middle
Well, we've given you this and
we call that subscriptions.

777
00:33:51.736 --> 00:33:51.816 A:middle
Yay.

778
00:33:52.516 --> 00:33:58.986 A:middle
[ Applause ]

779
00:33:59.486 --> 00:34:01.436 A:middle
So subscriptions are
exposed in our API

780
00:34:01.436 --> 00:34:03.516 A:middle
as the CKSubscription class.

781
00:34:03.986 --> 00:34:07.106 A:middle
They combine a record
type, a predicate and push.

782
00:34:08.186 --> 00:34:10.496 A:middle
Push is delivered via
the Apple Push Service.

783
00:34:10.496 --> 00:34:12.676 A:middle
If you've used APS in the
past, you're largely familiar

784
00:34:12.676 --> 00:34:16.116 A:middle
with this, but note CloudKit
pushes are slightly augmented.

785
00:34:16.346 --> 00:34:18.476 A:middle
They contain CloudKit
specific information

786
00:34:18.746 --> 00:34:20.246 A:middle
about what caused
the push to happen.

787
00:34:20.576 --> 00:34:21.985 A:middle
Let's have a look at an example.

788
00:34:23.726 --> 00:34:26.516 A:middle
Here we have a phone and that
phone is interested in parties

789
00:34:26.516 --> 00:34:27.985 A:middle
that are going to be
happening in the future.

790
00:34:28.936 --> 00:34:31.866 A:middle
This phone when it sees that
happening wants to be alerted

791
00:34:31.866 --> 00:34:33.335 A:middle
with a push that
says party time.

792
00:34:34.005 --> 00:34:36.426 A:middle
The phone is going to go ahead
and save that up to iCloud

793
00:34:36.516 --> 00:34:39.235 A:middle
and iCloud is going to,
you know, shuffle it away

794
00:34:39.235 --> 00:34:40.505 A:middle
with all the other
subscriptions.

795
00:34:41.436 --> 00:34:42.576 A:middle
Now along comes the Mac.

796
00:34:42.886 --> 00:34:44.275 A:middle
The Mac creates a new record.

797
00:34:44.505 --> 00:34:46.706 A:middle
It's a record-type party
and it's happening tonight

798
00:34:47.266 --> 00:34:50.295 A:middle
and because the Mac didn't chose
to give us a RecordID we created

799
00:34:50.295 --> 00:34:52.306 A:middle
that random UUID you see.

800
00:34:52.746 --> 00:34:55.795 A:middle
The Mac goes ahead and
saves that to ICloud.

801
00:34:55.795 --> 00:34:58.756 A:middle
ICloud is then going
to loop through all

802
00:34:58.756 --> 00:35:00.376 A:middle
of the subscriptions
that it knows about.

803
00:35:00.756 --> 00:35:02.256 A:middle
Eventually it's going
to come across this one.

804
00:35:02.936 --> 00:35:04.556 A:middle
It's going to check
and say, yeah, okay,

805
00:35:04.556 --> 00:35:07.286 A:middle
this is a new party and, yeah,
it's happening in the future.

806
00:35:07.946 --> 00:35:10.496 A:middle
So at that point it's going to
create a push and it's going

807
00:35:10.496 --> 00:35:12.796 A:middle
to take some information
from the subscription.

808
00:35:13.206 --> 00:35:15.476 A:middle
Here it took the alert
string party time.

809
00:35:16.066 --> 00:35:17.446 A:middle
It's going to take
other information

810
00:35:17.656 --> 00:35:19.066 A:middle
from the record itself.

811
00:35:19.066 --> 00:35:20.556 A:middle
Here we're pulling
in the RecordID.

812
00:35:21.186 --> 00:35:23.316 A:middle
Now that I've constructed
this augmented payload,

813
00:35:23.426 --> 00:35:25.946 A:middle
I can send that augmented
payload down to all clients

814
00:35:25.996 --> 00:35:28.126 A:middle
that are registered
and interested in it.

815
00:35:29.316 --> 00:35:30.706 A:middle
So let's look at some code.

816
00:35:31.246 --> 00:35:32.526 A:middle
How do I create a subscription?

817
00:35:33.126 --> 00:35:37.356 A:middle
Well, a subscription combines
a record type and a predicate.

818
00:35:38.826 --> 00:35:41.136 A:middle
Because a subscription
is also in charge

819
00:35:41.136 --> 00:35:43.596 A:middle
of telling the server how
you want to be alerted,

820
00:35:44.106 --> 00:35:46.516 A:middle
we introduce a notion
called CKNotificationInfo.

821
00:35:47.546 --> 00:35:51.826 A:middle
Here we're requesting that
the server badges our icon,

822
00:35:51.826 --> 00:35:54.626 A:middle
that it plays a particular sound
pulled out of my resources,

823
00:35:55.296 --> 00:35:57.916 A:middle
and that it shows an alert
string based on a string

824
00:35:57.916 --> 00:35:59.166 A:middle
in my localized strings file.

825
00:35:59.846 --> 00:36:02.186 A:middle
I can associate that
notification info

826
00:36:02.186 --> 00:36:04.846 A:middle
with a subscription and now
I've created everything I need

827
00:36:04.846 --> 00:36:05.556 A:middle
in my subscription.

828
00:36:06.266 --> 00:36:07.636 A:middle
Let's go ahead and
save it to the server.

829
00:36:08.826 --> 00:36:11.926 A:middle
As you might imagine via the
convenience API, it's simple,

830
00:36:11.926 --> 00:36:14.176 A:middle
it's asynchronous and it's
got great error handling.

831
00:36:14.656 --> 00:36:18.566 A:middle
Let's look at how you're going
to be handling subscriptions,

832
00:36:18.566 --> 00:36:20.446 A:middle
how you're going to handle
pushes as they come in.

833
00:36:20.946 --> 00:36:23.676 A:middle
If you've used APS in the
past, you're probably familiar

834
00:36:23.676 --> 00:36:24.536 A:middle
with this code snippet.

835
00:36:25.116 --> 00:36:27.216 A:middle
This is your application
delegate implementing the

836
00:36:27.216 --> 00:36:30.306 A:middle
ApplicationDidReceive
from notification method.

837
00:36:31.436 --> 00:36:34.406 A:middle
Now in most scenarios
if you know the format

838
00:36:34.406 --> 00:36:36.206 A:middle
of the push payload
that's coming in,

839
00:36:36.496 --> 00:36:38.666 A:middle
you would just then iterate
through that dictionary pulling

840
00:36:38.666 --> 00:36:40.236 A:middle
out the key value pairs
that you care about.

841
00:36:41.076 --> 00:36:42.656 A:middle
However, because
CloudKit was the one

842
00:36:42.656 --> 00:36:43.846 A:middle
that generated this push,

843
00:36:44.376 --> 00:36:46.366 A:middle
we ask that you let
CloudKit do that parsing.

844
00:36:47.026 --> 00:36:50.346 A:middle
So the way you would do that
is via CKNotification then

845
00:36:50.346 --> 00:36:53.186 A:middle
that really long one
I'm not going to name.

846
00:36:53.396 --> 00:36:55.026 A:middle
Once we've actually parsed

847
00:36:55.026 --> 00:36:58.326 A:middle
out a CKNotification you can
pull off APS level information

848
00:36:58.326 --> 00:37:02.126 A:middle
from it and you can also pull
off CloudKit level information

849
00:37:02.126 --> 00:37:02.966 A:middle
from it.

850
00:37:03.186 --> 00:37:06.486 A:middle
Here we're taking the
RecordID of the saved record

851
00:37:06.876 --> 00:37:08.036 A:middle
that caused the push to happen.

852
00:37:09.476 --> 00:37:12.626 A:middle
So between queries and
subscriptions we have an answer

853
00:37:12.626 --> 00:37:14.506 A:middle
to the big data,
tiny phone problem.

854
00:37:14.796 --> 00:37:17.036 A:middle
You're going to leave your
large data up in the cloud

855
00:37:17.336 --> 00:37:19.816 A:middle
and you're going to use
these two capabilities

856
00:37:19.816 --> 00:37:24.016 A:middle
to give your users a quick
view into that large dataset.

857
00:37:24.146 --> 00:37:28.846 A:middle
Now, I want to talk about
CloudKit user accounts.

858
00:37:30.986 --> 00:37:33.926 A:middle
As Olivier mentioned,
CloudKit is built on top

859
00:37:33.926 --> 00:37:35.526 A:middle
of the iCloud account
infrastructure.

860
00:37:36.026 --> 00:37:37.036 A:middle
So what does that mean?

861
00:37:37.036 --> 00:37:41.466 A:middle
I want to focus a little bit
on how accounts are exposed

862
00:37:41.466 --> 00:37:43.626 A:middle
to you explicitly
throughout the API.

863
00:37:44.546 --> 00:37:46.116 A:middle
When you think about
an account system,

864
00:37:46.426 --> 00:37:48.036 A:middle
the first thing you think
about is authentication

865
00:37:48.546 --> 00:37:50.936 A:middle
and CloudKit supports
authentication via the logged

866
00:37:50.936 --> 00:37:53.096 A:middle
in iCloud user, but
that's not, you know,

867
00:37:53.096 --> 00:37:54.886 A:middle
that's sort of behind the
scenes and you guys don't care

868
00:37:54.886 --> 00:37:55.866 A:middle
about that, that's implicit.

869
00:37:55.976 --> 00:37:57.626 A:middle
Let's talk about
the explicit things.

870
00:37:58.286 --> 00:38:00.556 A:middle
What do we give you
because we're built

871
00:38:00.556 --> 00:38:01.746 A:middle
on top of iCloud accounts?

872
00:38:02.436 --> 00:38:05.006 A:middle
We give you identity; a way
of identifying the user.

873
00:38:05.716 --> 00:38:08.076 A:middle
We give you metadata;
the ability to save

874
00:38:08.076 --> 00:38:09.816 A:middle
and retrieve information
about users.

875
00:38:10.776 --> 00:38:13.186 A:middle
We do all of this in a
privacy conscientious manner

876
00:38:13.186 --> 00:38:14.476 A:middle
and we don't want
to disclose anything

877
00:38:14.476 --> 00:38:16.736 A:middle
if the user hasn't agreed to it

878
00:38:17.126 --> 00:38:19.066 A:middle
and lastly we give
users the ability

879
00:38:19.066 --> 00:38:21.856 A:middle
to discover their friends that
are using your application.

880
00:38:22.506 --> 00:38:24.336 A:middle
Let's dive into each
one of these.

881
00:38:24.566 --> 00:38:26.346 A:middle
First of all we're going
to talk about identity.

882
00:38:27.436 --> 00:38:29.076 A:middle
So, here's our model.

883
00:38:29.076 --> 00:38:30.836 A:middle
We've got our client,
our application running

884
00:38:30.836 --> 00:38:32.966 A:middle
on the client, and all
of these different users

885
00:38:32.966 --> 00:38:34.786 A:middle
and their private databases
up in the container.

886
00:38:36.376 --> 00:38:39.536 A:middle
Your specific client is
going to be linked to one

887
00:38:39.536 --> 00:38:40.856 A:middle
and only one of those users.

888
00:38:41.036 --> 00:38:45.396 A:middle
This is related to
the user that's logged

889
00:38:45.396 --> 00:38:47.496 A:middle
in via iCloud locally
on your device.

890
00:38:48.546 --> 00:38:51.556 A:middle
Because this is iCloud we've
got a rich backing store

891
00:38:51.556 --> 00:38:54.756 A:middle
of user information and
because iCloud is the one

892
00:38:55.136 --> 00:38:59.386 A:middle
that is hosting your container
we can correlate users.

893
00:38:59.636 --> 00:39:01.776 A:middle
For example, here we
see that the user,

894
00:39:01.776 --> 00:39:04.116 A:middle
whose email address is
c at iCloud dot com,

895
00:39:04.536 --> 00:39:06.246 A:middle
is linked to your
current client.

896
00:39:07.366 --> 00:39:11.166 A:middle
So given this setup how are we
going to present an identity?

897
00:39:11.166 --> 00:39:13.356 A:middle
How are we going to let
you know, your client,

898
00:39:13.356 --> 00:39:16.436 A:middle
your application, know
what user is logged in?

899
00:39:16.926 --> 00:39:19.266 A:middle
Well, natively you might
think let's give them an

900
00:39:19.266 --> 00:39:19.916 A:middle
email address.

901
00:39:20.156 --> 00:39:21.876 A:middle
We're not going to
do that obviously.

902
00:39:22.446 --> 00:39:25.376 A:middle
That's private user
identifiable information

903
00:39:25.376 --> 00:39:26.636 A:middle
and we don't want
to give that out.

904
00:39:27.446 --> 00:39:29.416 A:middle
So, instead what we
do is on a container

905
00:39:29.416 --> 00:39:33.036 A:middle
by container basis we
come up with a random ID.

906
00:39:33.366 --> 00:39:35.586 A:middle
This is an identifier
that is stable

907
00:39:35.656 --> 00:39:39.036 A:middle
so that is your application no
matter what client it's running

908
00:39:39.036 --> 00:39:42.676 A:middle
on talking to this container
will get the same identifier,

909
00:39:43.096 --> 00:39:46.306 A:middle
but it's not identifying
the user via any

910
00:39:46.306 --> 00:39:47.166 A:middle
personal information.

911
00:39:48.056 --> 00:39:51.706 A:middle
So we feel confident
giving you this identifier.

912
00:39:52.066 --> 00:39:54.316 A:middle
You can take this identifier
and do with it what you will.

913
00:39:55.276 --> 00:39:58.796 A:middle
Note that different applications
running on your phone

914
00:39:58.796 --> 00:40:03.426 A:middle
because they're talking to
different containers are going

915
00:40:03.426 --> 00:40:06.256 A:middle
to get back different container
scoped RecordIdentifiers

916
00:40:06.476 --> 00:40:07.286 A:middle
for the same user.

917
00:40:08.146 --> 00:40:09.976 A:middle
This goes back to what we
talked about in the beginning

918
00:40:09.976 --> 00:40:14.926 A:middle
that we've got user
encapsulation.

919
00:40:15.046 --> 00:40:15.556 A:middle
So user identity.

920
00:40:15.676 --> 00:40:19.346 A:middle
We expose user identity
via API as a user RecordID.

921
00:40:20.016 --> 00:40:22.216 A:middle
It is a stable identifier
for this user.

922
00:40:22.606 --> 00:40:24.796 A:middle
It will be the same for
your application no matter

923
00:40:24.796 --> 00:40:26.086 A:middle
where your application
is running.

924
00:40:26.716 --> 00:40:29.296 A:middle
It's scoped to the container

925
00:40:29.576 --> 00:40:31.446 A:middle
so 2 different applications
are going to come

926
00:40:31.446 --> 00:40:33.726 A:middle
up with different
identifiers for the same user.

927
00:40:34.096 --> 00:40:36.196 A:middle
This is a feature.

928
00:40:36.196 --> 00:40:37.986 A:middle
Lastly this is an
independent API.

929
00:40:38.156 --> 00:40:40.006 A:middle
This is a section of
the CloudKit framework.

930
00:40:40.646 --> 00:40:42.076 A:middle
You can use this
in collaboration

931
00:40:42.076 --> 00:40:45.496 A:middle
with the database API or you can
use this completely separately.

932
00:40:45.756 --> 00:40:48.006 A:middle
We've given you enough
support that if you wanted

933
00:40:48.006 --> 00:40:51.076 A:middle
to you could implement
a login via iCloud flow

934
00:40:51.336 --> 00:40:53.496 A:middle
in your application using
the CloudKit framework.

935
00:40:54.426 --> 00:40:56.846 A:middle
Let's have a look at the code.

936
00:40:57.516 --> 00:41:00.806 A:middle
[ Applause ]

937
00:41:01.306 --> 00:41:02.746 A:middle
All right let's have
a look at the code.

938
00:41:03.396 --> 00:41:06.106 A:middle
Because identity is a
container-scoped notion

939
00:41:06.246 --> 00:41:09.396 A:middle
and not a database-scoped
notion, we go to our container

940
00:41:09.396 --> 00:41:10.356 A:middle
to learn about our user.

941
00:41:11.116 --> 00:41:13.946 A:middle
Here we're asking our container
to fetch the user RecordID.

942
00:41:15.276 --> 00:41:18.116 A:middle
Now because we may have
to talk to the server

943
00:41:18.116 --> 00:41:20.666 A:middle
to figure this out, for example,
the first time you access

944
00:41:20.666 --> 00:41:22.886 A:middle
and try to learn about
a RecordID we have to go

945
00:41:22.886 --> 00:41:25.376 A:middle
to the server to do that
translation and come

946
00:41:25.376 --> 00:41:26.626 A:middle
up with a container-scoped info.

947
00:41:27.086 --> 00:41:29.566 A:middle
So, asynchronous and we
have to do error handling.

948
00:41:31.296 --> 00:41:32.666 A:middle
That's user identity.

949
00:41:32.966 --> 00:41:35.576 A:middle
Let's talk about user
metadata and quickly

950
00:41:35.576 --> 00:41:38.996 A:middle
to recap the problem what we
have here is we have a stable

951
00:41:38.996 --> 00:41:40.946 A:middle
identifier and we've
got a desire

952
00:41:41.006 --> 00:41:44.476 A:middle
to set key value pairs
based on that identifier.

953
00:41:45.106 --> 00:41:47.776 A:middle
I don't know about you but
to me that sounds very much

954
00:41:47.776 --> 00:41:49.326 A:middle
like what a record
was built to do.

955
00:41:49.906 --> 00:41:53.086 A:middle
So we expose users
as user records.

956
00:41:55.036 --> 00:41:56.086 A:middle
Looking inside a container

957
00:41:56.086 --> 00:41:58.696 A:middle
within a database we see
there is one user record

958
00:41:58.696 --> 00:41:59.886 A:middle
in the private database

